# 小程序菜单设计规范

## 1. 菜单设计原则

### 1.1 核心设计理念

**简洁性原则：**
- 菜单层级不超过3级（根菜单 → 一级 → 二级）
- 每级菜单项数量控制在3-7个之间
- 避免功能重复和冗余路径

**一致性原则：**
- 统一的图标风格和色彩体系
- 一致的交互行为和动画效果
- 标准化的命名规范

**可访问性原则：**
- 支持无障碍访问
- 适配不同屏幕尺寸
- 考虑单手操作便利性

### 1.2 用户体验目标

- **效率优先**：核心功能3步内到达
- **直观易懂**：图标+文字双重标识
- **个性化**：支持用户自定义和角色差异
- **响应迅速**：菜单切换动画<300ms

## 2. 菜单层级架构

### 2.1 四级菜单结构

```
小程序菜单架构
├── 🏠 根菜单 (TabBar)
│   ├── 📱 一级菜单 (主功能模块)
│   │   ├── 🔧 二级菜单 (子功能分类)
│   │   └── 🔧 二级菜单
│   └── 📱 一级菜单
└── 🏠 根菜单
```

### 2.2 菜单类型定义

| 菜单级别 | 展示形式 | 功能定位 | 数量限制 | 示例 |
|----------|----------|----------|----------|------|
| **根菜单** | TabBar底部导航 | 主要功能入口 | 3-5个 | 斩词、工具、时尚、我的 |
| **一级菜单** | 页面内容区 | 功能模块分类 | 4-8个 | 单词学习、单词挑战、单词复习、社区 |
| **二级菜单** | 列表/网格布局 | 具体功能分组 | 3-6个 | 单词拼写、闪卡练习、阅读理解 |
| **三级菜单** | 详情页/弹窗 | 最终操作项 | 2-5个 | 开始练习、查看详情、设置难度 |


## 3. 角色差异化设计

### 3.1 角色菜单权限矩阵

| 功能模块 | 学生 | 家长 | 教师 | 教研组长 | 教务主任 | 教导主任 | 管理员 | 权限代码 |
|----------|------|------|------|----------|----------|----------|--------|----------|
| **🏠 仪表板** | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | `dashboard_access` |
| **📚 单词学习** | ✅ | 👁️ | ✅ | ✅ | ✅ | ✅ | ✅ | `word_learning_access` |
| **✏️ 单词拼写** | ✅ | 👁️ | ✅ | ✅ | ✅ | ✅ | ✅ | `word_spelling_access` |
| **📖 阅读理解** | ✅ | 👁️ | ✅ | ✅ | ✅ | ✅ | ✅ | `word_reading_access` |
| **🎧 听力练习** | ✅ | 👁️ | ✅ | ✅ | ✅ | ✅ | ✅ | `listening_access` |
| **🎯 单词挑战** | ✅ | 👁️ | ✅ | ✅ | ✅ | ✅ | ✅ | `competition_access` |
| **🔄 单词复习** | ✅ | 👁️ | ✅ | ✅ | ✅ | ✅ | ✅ | `word_review_access` |
| **👥 社区功能** | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | `community_access` |
| **📊 学生进度** | 🔒 | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | `student_progress_view` |
| **👨‍🏫 班级管理** | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | `class_management` |
| **📈 数据分析** | ❌ | 🔒 | 🔒 | ✅ | ✅ | ✅ | ✅ | `analytics_access` |
| **👤 用户管理** | ❌ | ❌ | ❌ | 🔒 | ✅ | ✅ | ✅ | `user_management` |
| **⚙️ 系统管理** | ❌ | ❌ | ❌ | ❌ | 🔒 | 🔒 | ✅ | `system_management` |
| **🔐 权限管理** | ❌ | ❌ | ❌ | ❌ | ❌ | 🔒 | ✅ | `permission_management` |
| **💳 订阅管理** | 🔒 | ✅ | ❌ | ❌ | ❌ | ❌ | ✅ | `subscription_management` |

**图例说明：**
- ✅ 完全访问权限
- 👁️ 只读查看权限
- 🔒 部分功能权限
- ❌ 无访问权限

### 3.2 角色菜单定制

**学生角色菜单：**
```json
{
  "tabBar": [
    {
      "text": "斩词",
      "iconPath": "/static/icons/slash-word.png",
      "selectedIconPath": "/static/icons/slash-word-active.png",
      "pagePath": "pages/slash-word/index",
      "permission": "word_learning_access"
    },
    {
      "text": "工具",
      "iconPath": "/static/icons/tools.png",
      "selectedIconPath": "/static/icons/tools-active.png",
      "pagePath": "pages/tools/index",
      "permission": "basic_access"
    },
    {
      "text": "时尚",
      "iconPath": "/static/icons/fashion.png",
      "selectedIconPath": "/static/icons/fashion-active.png",
      "pagePath": "pages/fashion/index",
      "permission": "community_access"
    },
    {
      "text": "我的",
      "iconPath": "/static/icons/profile.png",
      "selectedIconPath": "/static/icons/profile-active.png",
      "pagePath": "pages/profile/index",
      "permission": "profile_access"
    }
  ],
  "menuItems": {
    "slash-word": [
      {
        "id": "word_learning",
        "title": "单词学习",
        "icon": "📚",
        "path": "/pages/learning/words",
        "permission": "word_learning_access",
        "sortOrder": 1,
        "children": [
          {
            "id": "word_spelling",
            "title": "单词拼写",
            "icon": "✏️",
            "path": "/pages/learning/spelling",
            "permission": "word_spelling_access"
          },
          {
            "id": "flashcard_practice",
            "title": "闪卡练习",
            "icon": "🃏",
            "path": "/pages/learning/flashcard",
            "permission": "word_learning_access"
          }
        ]
      },
      {
        "id": "word_challenge",
        "title": "单词挑战",
        "icon": "🎯",
        "path": "/pages/challenge/index",
        "permission": "competition_access",
        "sortOrder": 2,
        "badge": "hot"
      },
      {
        "id": "word_review",
        "title": "单词复习",
        "icon": "🔄",
        "path": "/pages/review/index",
        "permission": "word_review_access",
        "sortOrder": 3
      },
      {
        "id": "reading_comprehension",
        "title": "阅读理解",
        "icon": "📖",
        "path": "/pages/reading/index",
        "permission": "word_reading_access",
        "sortOrder": 4
      },
      {
        "id": "listening_practice",
        "title": "听力练习",
        "icon": "🎧",
        "path": "/pages/listening/index",
        "permission": "listening_access",
        "sortOrder": 5
      }
    ],
    "tools": [
      {
        "id": "dictionary",
        "title": "词典查询",
        "icon": "📖",
        "path": "/pages/tools/dictionary",
        "permission": "basic_access"
      },
      {
        "id": "translator",
        "title": "翻译工具",
        "icon": "🔄",
        "path": "/pages/tools/translator",
        "permission": "basic_access"
      }
    ],
    "fashion": [
      {
        "id": "community",
        "title": "学习社区",
        "icon": "👥",
        "path": "/pages/community/index",
        "permission": "community_access"
      },
      {
        "id": "ranking",
        "title": "排行榜",
        "icon": "🏆",
        "path": "/pages/ranking/index",
        "permission": "community_access"
      }
    ]
  }
}
```

**教师角色菜单：**
```json
{
  "tabBar": [
    {
      "text": "斩词",
      "iconPath": "/static/icons/slash-word.png",
      "selectedIconPath": "/static/icons/slash-word-active.png",
      "pagePath": "pages/slash-word/index",
      "permission": "word_learning_access"
    },
    {
      "text": "工具",
      "iconPath": "/static/icons/tools.png",
      "selectedIconPath": "/static/icons/tools-active.png",
      "pagePath": "pages/tools/index",
      "permission": "basic_access"
    },
    {
      "text": "时尚",
      "iconPath": "/static/icons/fashion.png",
      "selectedIconPath": "/static/icons/fashion-active.png",
      "pagePath": "pages/fashion/index",
      "permission": "community_access"
    },
    {
      "text": "我的",
      "iconPath": "/static/icons/profile.png",
      "selectedIconPath": "/static/icons/profile-active.png",
      "pagePath": "pages/profile/teacher",
      "permission": "profile_access"
    }
  ],
  "menuItems": {
    "tools": [
      {
        "id": "class_management",
        "title": "班级管理",
        "icon": "👥",
        "path": "/pages/teacher/classes",
        "permission": "class_management",
        "sortOrder": 1
      },
      {
        "id": "student_progress",
        "title": "学生进度",
        "icon": "📊",
        "path": "/pages/teacher/progress",
        "permission": "student_progress_view",
        "sortOrder": 2
      },
      {
        "id": "teaching_resources",
        "title": "教学资源",
        "icon": "📁",
        "path": "/pages/teacher/resources",
        "permission": "teacher_access",
        "sortOrder": 3
      },
      {
        "id": "data_analytics",
        "title": "数据分析",
        "icon": "📈",
        "path": "/pages/teacher/analytics",
        "permission": "analytics_access",
        "sortOrder": 4
      }
    ]
  }
}
```

## 4. 用户自定义菜单

### 4.1 自定义功能设计

**可自定义元素：**

| 自定义项 | 范围 | 限制 | 说明 | 权限要求 |
|----------|------|------|------|----------|
| **菜单顺序** | 一级、二级菜单 | 不可跨级调整 | 拖拽排序 | `menu_customize` |
| **菜单显示/隐藏** | 二级、三级菜单 | 必须保留核心功能 | 开关控制 | `menu_customize` |
| **快捷入口** | 首页快捷按钮 | 最多6个 | 常用功能快速访问 | `basic_access` |
| **菜单图标** | 所有级别 | 预设图标库 | 个性化展示 | `menu_customize` |
| **菜单名称** | 二级、三级菜单 | 字符长度限制 | 个人习惯命名 | `menu_customize` |
| **主题色彩** | 全局菜单 | 预设主题方案 | 视觉个性化 | `basic_access` |

**自定义限制：**
- 核心功能不可隐藏
- 菜单结构不可破坏
- 权限范围内自定义
- 需要相应权限验证

### 4.2 自定义配置数据结构

```typescript
interface UserMenuConfig {
  userId: string
  role: 'student' | 'teacher' | 'parent' | 'admin'
  permissions: string[]           // 用户权限列表
  customization: {
    tabBarOrder: string[]           // TabBar 排序
    quickActions: QuickAction[]     // 快捷操作
    hiddenMenus: string[]          // 隐藏的菜单项
    customIcons: Record<string, string>  // 自定义图标映射
    customNames: Record<string, string>  // 自定义名称映射
    theme: {
      primaryColor: string         // 主题色
      accentColor: string         // 强调色
      iconStyle: 'outline' | 'filled' // 图标风格
      darkMode: boolean           // 深色模式
    }
    layout: {
      gridColumns: number          // 网格列数
      showBadges: boolean         // 显示徽章
      compactMode: boolean        // 紧凑模式
    }
  }
  lastModified: string
  version: string                 // 配置版本
}

interface QuickAction {
  id: string
  title: string
  icon: string
  path: string
  order: number
  permission: string             // 所需权限
}

// 菜单权限验证配置
interface MenuPermissionConfig {
  menuId: string
  requiredPermissions: string[]
  fallbackMenu?: string          // 无权限时的替代菜单
  customizable: boolean          // 是否可自定义
}
```

### 4.3 菜单权限验证机制

#### 权限验证流程
```javascript
// 菜单权限验证服务
class MenuPermissionService {
  // 验证用户是否有菜单访问权限
  static async validateMenuAccess(userId, menuId) {
    const userPermissions = await this.getUserPermissions(userId);
    const menuConfig = await this.getMenuConfig(menuId);
    
    // 检查必需权限
    const hasRequiredPermissions = menuConfig.requiredPermissions.every(
      permission => userPermissions.includes(permission)
    );
    
    if (!hasRequiredPermissions) {
      // 返回替代菜单或隐藏
      return {
        accessible: false,
        fallbackMenu: menuConfig.fallbackMenu,
        reason: 'insufficient_permissions'
      };
    }
    
    return { accessible: true };
  }
  
  // 过滤用户可访问的菜单
  static async filterAccessibleMenus(userId, menuList) {
    const accessibleMenus = [];
    
    for (const menu of menuList) {
      const validation = await this.validateMenuAccess(userId, menu.id);
      
      if (validation.accessible) {
        // 递归过滤子菜单
        if (menu.children) {
          menu.children = await this.filterAccessibleMenus(userId, menu.children);
        }
        accessibleMenus.push(menu);
      } else if (validation.fallbackMenu) {
        // 添加替代菜单
        const fallback = await this.getMenuConfig(validation.fallbackMenu);
        accessibleMenus.push(fallback);
      }
    }
    
    return accessibleMenus;
  }
}
```

#### 动态菜单加载
```javascript
// 动态菜单加载器
class DynamicMenuLoader {
  static async loadUserMenu(userId, role) {
    try {
      // 1. 获取基础菜单配置
      const baseMenuConfig = await this.getBaseMenuConfig(role);
      
      // 2. 获取用户自定义配置
      const userCustomConfig = await this.getUserCustomConfig(userId);
      
      // 3. 权限过滤
      const filteredMenus = await MenuPermissionService.filterAccessibleMenus(
        userId, 
        baseMenuConfig.menuItems
      );
      
      // 4. 应用用户自定义
      const customizedMenus = this.applyUserCustomization(
        filteredMenus, 
        userCustomConfig
      );
      
      // 5. 缓存菜单配置
      await this.cacheMenuConfig(userId, customizedMenus);
      
      return {
        tabBar: this.buildTabBar(customizedMenus, userCustomConfig),
        menuItems: customizedMenus,
        shortcuts: userCustomConfig.shortcuts || [],
        theme: userCustomConfig.theme || this.getDefaultTheme()
      };
      
    } catch (error) {
      console.error('菜单加载失败:', error);
      // 返回默认菜单
      return this.getDefaultMenuConfig(role);
    }
  }
  
  // 应用用户自定义配置
  static applyUserCustomization(menuItems, customConfig) {
    return menuItems.map(menu => {
      // 应用自定义名称
      if (customConfig.customNames?.[menu.id]) {
        menu.title = customConfig.customNames[menu.id];
      }
      
      // 应用自定义图标
      if (customConfig.customIcons?.[menu.id]) {
        menu.icon = customConfig.customIcons[menu.id];
      }
      
      // 过滤隐藏的菜单
      if (customConfig.hiddenMenus?.includes(menu.id)) {
        return null;
      }
      
      return menu;
    }).filter(Boolean);
  }
}
```

### 4.4 自定义界面设计

```vue
<template>
  <view class="menu-customization">
    <!-- 预览区域 -->
    <view class="preview-section">
      <text class="section-title">预览效果</text>
      <view class="mock-tabbar">
        <view 
          v-for="(item, index) in customTabBar" 
          :key="item.id"
          class="tab-item"
          :class="{ active: index === 0 }"
        >
          <image :src="item.icon" class="tab-icon" />
          <text class="tab-text">{{ item.text }}</text>
        </view>
      </view>
    </view>
    
    <!-- 编辑区域 -->
    <view class="edit-section">
      <text class="section-title">自定义设置</text>
      
      <!-- 菜单排序 -->
      <view class="setting-group">
        <text class="group-title">菜单排序</text>
        <movable-area class="sortable-area">
          <movable-view 
            v-for="(item, index) in editableMenus"
            :key="item.id"
            class="sortable-item"
            direction="vertical"
            @change="onMenuSort"
          >
            <view class="menu-item">
              <image :src="item.icon" class="item-icon" />
              <text class="item-title">{{ item.title }}</text>
              <view class="drag-handle">⋮⋮</view>
            </view>
          </movable-view>
        </movable-area>
      </view>
      
      <!-- 主题设置 -->
      <view class="setting-group">
        <text class="group-title">主题设置</text>
        <view class="theme-options">
          <view 
            v-for="color in themeColors"
            :key="color"
            class="color-option"
            :class="{ selected: selectedTheme === color }"
            :style="{ backgroundColor: color }"
            @click="selectTheme(color)"
          />
        </view>
      </view>
    </view>
    
    <!-- 操作按钮 -->
    <view class="action-buttons">
      <button class="btn-reset" @click="resetToDefault">恢复默认</button>
      <button class="btn-save" @click="saveCustomization">保存设置</button>
    </view>
  </view>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { useMenuStore } from '@/store/modules/menu'

const menuStore = useMenuStore()

// 可编辑菜单列表
const editableMenus = ref([
  { id: 'learning', title: '学习中心', icon: '/static/icons/study.png' },
  { id: 'progress', title: '学习进度', icon: '/static/icons/progress.png' },
  { id: 'profile', title: '个人中心', icon: '/static/icons/profile.png' }
])

// 主题色选项
const themeColors = ['#007AFF', '#34C759', '#FF9500', '#FF3B30', '#5856D6']
const selectedTheme = ref('#007AFF')

// 自定义 TabBar
const customTabBar = computed(() => {
  return editableMenus.value.map(item => ({
    ...item,
    text: item.title
  }))
})

// 菜单排序
const onMenuSort = (event: any) => {
  // 处理拖拽排序逻辑
}

// 选择主题
const selectTheme = (color: string) => {
  selectedTheme.value = color
}

// 重置为默认
const resetToDefault = () => {
  menuStore.resetMenuCustomization()
}

// 保存自定义设置
const saveCustomization = async () => {
  try {
    await menuStore.saveMenuCustomization({
      tabBarOrder: editableMenus.value.map(item => item.id),
      theme: {
        primaryColor: selectedTheme.value,
        iconStyle: 'filled'
      }
    })
    
    uni.showToast({
      title: '保存成功',
      icon: 'success'
    })
  } catch (error) {
    uni.showToast({
      title: '保存失败',
      icon: 'error'
    })
  }
}
</script>
```

## 5. 菜单交互设计

### 5.1 交互状态定义

**菜单项状态：**
- **默认状态**：正常显示
- **悬停状态**：轻微高亮（H5适用）
- **激活状态**：明显高亮+图标变化
- **禁用状态**：灰色显示+不可点击
- **加载状态**：显示加载动画
- **隐藏状态**：权限不足时完全隐藏
- **徽章状态**：显示消息提醒或更新标识

**状态样式规范：**
```scss
.menu-item {
  transition: all 0.3s ease;
  
  // 默认状态
  &.default {
    opacity: 1;
    transform: scale(1);
  }
  
  // 激活状态
  &.active {
    background-color: var(--primary-color);
    color: #ffffff;
    transform: scale(1.05);
  }
  
  // 禁用状态
  &.disabled {
    opacity: 0.5;
    pointer-events: none;
  }
  
  // 加载状态
  &.loading {
    position: relative;
    
    &::after {
      content: '';
      position: absolute;
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
  }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
```

### 5.2 手势交互

**支持的手势：**
- **点击**：进入下级菜单或执行功能
- **长按**：显示快捷操作菜单
- **滑动**：TabBar 左右切换（可选）
- **下拉刷新**：刷新菜单数据

**手势实现：**
```vue
<template>
  <view 
    class="menu-item"
    @tap="onTap"
    @longpress="onLongPress"
    @touchstart="onTouchStart"
    @touchmove="onTouchMove"
    @touchend="onTouchEnd"
  >
    <!-- 菜单内容 -->
  </view>
</template>

<script setup lang="ts">
let touchStartTime = 0
let touchStartX = 0
let touchStartY = 0

const onTap = () => {
  // 点击处理
}

const onLongPress = () => {
  // 长按处理
  uni.vibrateShort() // 震动反馈
}

const onTouchStart = (event: TouchEvent) => {
  touchStartTime = Date.now()
  touchStartX = event.touches[0].clientX
  touchStartY = event.touches[0].clientY
}

const onTouchMove = (event: TouchEvent) => {
  // 滑动处理
}

const onTouchEnd = (event: TouchEvent) => {
  const touchEndTime = Date.now()
  const touchDuration = touchEndTime - touchStartTime
  
  if (touchDuration < 200) {
    // 快速点击
  }
}
</script>
```

## 6. 响应式设计

### 6.1 屏幕适配

**断点定义：**
```scss
// 屏幕尺寸断点
$breakpoints: (
  'small': 320px,   // 小屏手机
  'medium': 375px,  // 中等手机
  'large': 414px,   // 大屏手机
  'tablet': 768px   // 平板
);

// 响应式混入
@mixin respond-to($breakpoint) {
  @media (min-width: map-get($breakpoints, $breakpoint)) {
    @content;
  }
}

// 菜单响应式样式
.menu-grid {
  display: grid;
  gap: 16px;
  
  // 小屏：2列
  grid-template-columns: repeat(2, 1fr);
  
  // 中等屏幕：3列
  @include respond-to('medium') {
    grid-template-columns: repeat(3, 1fr);
  }
  
  // 大屏：4列
  @include respond-to('large') {
    grid-template-columns: repeat(4, 1fr);
  }
}
```

### 6.2 动态布局

```typescript
// 动态计算菜单布局
interface LayoutConfig {
  columns: number
  itemSize: number
  gap: number
}

export function calculateMenuLayout(): LayoutConfig {
  const systemInfo = uni.getSystemInfoSync()
  const screenWidth = systemInfo.screenWidth
  const safeAreaWidth = screenWidth - 32 // 左右边距
  
  let columns = 2
  let itemSize = 80
  let gap = 16
  
  if (screenWidth >= 414) {
    columns = 4
    itemSize = 90
    gap = 20
  } else if (screenWidth >= 375) {
    columns = 3
    itemSize = 85
    gap = 18
  }
  
  // 重新计算确保完美适配
  const totalGap = (columns - 1) * gap
  const availableWidth = safeAreaWidth - totalGap
  itemSize = Math.floor(availableWidth / columns)
  
  return { columns, itemSize, gap }
}
```

## 7. 性能优化

### 7.1 菜单懒加载

```typescript
// 菜单数据懒加载
interface MenuModule {
  id: string
  title: string
  component?: any
  children?: MenuModule[]
}

class MenuLoader {
  private loadedModules = new Map<string, any>()
  private loadingPromises = new Map<string, Promise<any>>()
  
  async loadMenuModule(moduleId: string): Promise<any> {
    if (this.loadedModules.has(moduleId)) {
      return this.loadedModules.get(moduleId)
    }
    
    // 避免重复加载
    if (this.loadingPromises.has(moduleId)) {
      return this.loadingPromises.get(moduleId)
    }
    
    const loadingPromise = this.doLoadModule(moduleId)
    this.loadingPromises.set(moduleId, loadingPromise)
    
    try {
      const module = await loadingPromise
      this.loadedModules.set(moduleId, module)
      return module
    } finally {
      this.loadingPromises.delete(moduleId)
    }
  }
  
  private async doLoadModule(moduleId: string): Promise<any> {
    try {
      const module = await import(`@/pages/${moduleId}/index.vue`)
      return module
    } catch (error) {
      console.error(`Failed to load menu module: ${moduleId}`, error)
      throw error
    }
  }
  
  preloadMenuModules(moduleIds: string[]) {
    moduleIds.forEach(id => {
      this.loadMenuModule(id).catch(() => {
        // 预加载失败不影响主流程
      })
    })
  }
  
  // 预加载用户常用菜单
  async preloadFrequentMenus(userId: string) {
    try {
      const analytics = await uni.getStorageSync(`menu_analytics_${userId}`)
      const frequentMenus = analytics?.frequentMenus || ['slash-word', 'tools', 'profile']
      this.preloadMenuModules(frequentMenus)
    } catch (error) {
      console.warn('预加载常用菜单失败:', error)
      this.preloadMenuModules(['slash-word', 'tools', 'profile'])
    }
  }
}

export const menuLoader = new MenuLoader()
```

### 7.2 菜单缓存策略

```typescript
// 菜单缓存管理
class MenuCache {
  private cache = new Map<string, any>()
  private cacheTimeout = 5 * 60 * 1000 // 5分钟
  private maxCacheSize = 50 // 最大缓存数量
  
  set(key: string, data: any) {
    // 检查缓存大小限制
    if (this.cache.size >= this.maxCacheSize) {
      this.evictLeastRecentlyUsed()
    }
    
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      accessCount: 1,
      lastAccess: Date.now()
    })
  }
  
  get(key: string): any | null {
    const cached = this.cache.get(key)
    if (!cached) return null
    
    const isExpired = Date.now() - cached.timestamp > this.cacheTimeout
    if (isExpired) {
      this.cache.delete(key)
      return null
    }
    
    // 更新访问统计
    cached.accessCount++
    cached.lastAccess = Date.now()
    
    return cached.data
  }
  
  // LRU缓存淘汰策略
  private evictLeastRecentlyUsed() {
    let lruKey = ''
    let oldestAccess = Date.now()
    
    for (const [key, value] of this.cache) {
      if (value.lastAccess < oldestAccess) {
        oldestAccess = value.lastAccess
        lruKey = key
      }
    }
    
    if (lruKey) {
      this.cache.delete(lruKey)
    }
  }
  
  clear() {
    this.cache.clear()
  }
  
  // 获取缓存统计信息
  getStats() {
    return {
      size: this.cache.size,
      maxSize: this.maxCacheSize,
      hitRate: this.calculateHitRate()
    }
  }
  
  private calculateHitRate(): number {
    let totalAccess = 0
    for (const [key, value] of this.cache) {
      totalAccess += value.accessCount
    }
    return totalAccess > 0 ? (this.cache.size / totalAccess) : 0
  }
}

export const menuCache = new MenuCache()
```

### 7.3 性能监控

```typescript
// 菜单性能监控
class MenuPerformanceMonitor {
  private metrics = new Map<string, any>()
  
  // 记录菜单加载时间
  startTiming(menuId: string) {
    this.metrics.set(`${menuId}_start`, performance.now())
  }
  
  endTiming(menuId: string) {
    const startTime = this.metrics.get(`${menuId}_start`)
    if (startTime) {
      const duration = performance.now() - startTime
      this.recordMetric('menu_load_time', menuId, duration)
      this.metrics.delete(`${menuId}_start`)
    }
  }
  
  // 记录菜单点击事件
  recordMenuClick(menuId: string) {
    this.recordMetric('menu_click', menuId, 1)
  }
  
  // 记录性能指标
  private recordMetric(type: string, menuId: string, value: number) {
    const key = `${type}_${menuId}`
    const existing = this.metrics.get(key) || { count: 0, total: 0, avg: 0 }
    
    existing.count++
    existing.total += value
    existing.avg = existing.total / existing.count
    
    this.metrics.set(key, existing)
  }
  
  // 获取性能报告
  getPerformanceReport() {
    const report: any = {}
    
    for (const [key, value] of this.metrics) {
      if (key.includes('menu_load_time')) {
        const menuId = key.replace('menu_load_time_', '')
        report[menuId] = {
          averageLoadTime: value.avg,
          loadCount: value.count
        }
      }
    }
    
    return report
  }
}

export const performanceMonitor = new MenuPerformanceMonitor()
```

## 8. 无障碍访问

### 8.1 无障碍属性

```vue
<template>
  <view 
    class="menu-item"
    role="button"
    :aria-label="menuItem.title"
    :aria-describedby="menuItem.description"
    tabindex="0"
    @click="onMenuClick"
    @keydown.enter="onMenuClick"
    @keydown.space="onMenuClick"
  >
    <image 
      :src="menuItem.icon"
      :alt="menuItem.title"
      class="menu-icon"
    />
    <text class="menu-title">{{ menuItem.title }}</text>
    <text 
      :id="menuItem.description"
      class="menu-description sr-only"
    >
      {{ menuItem.description }}
    </text>
  </view>
</template>

<style>
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
</style>
```

### 8.2 键盘导航

```typescript
// 键盘导航支持
export function useKeyboardNavigation() {
  const currentFocusIndex = ref(0)
  const menuItems = ref<HTMLElement[]>([])
  
  const handleKeyDown = (event: KeyboardEvent) => {
    switch (event.key) {
      case 'ArrowDown':
        event.preventDefault()
        focusNext()
        break
      case 'ArrowUp':
        event.preventDefault()
        focusPrevious()
        break
      case 'Home':
        event.preventDefault()
        focusFirst()
        break
      case 'End':
        event.preventDefault()
        focusLast()
        break
    }
  }
  
  const focusNext = () => {
    currentFocusIndex.value = Math.min(
      currentFocusIndex.value + 1,
      menuItems.value.length - 1
    )
    focusCurrent()
  }
  
  const focusPrevious = () => {
    currentFocusIndex.value = Math.max(currentFocusIndex.value - 1, 0)
    focusCurrent()
  }
  
  const focusFirst = () => {
    currentFocusIndex.value = 0
    focusCurrent()
  }
  
  const focusLast = () => {
    currentFocusIndex.value = menuItems.value.length - 1
    focusCurrent()
  }
  
  const focusCurrent = () => {
    const currentItem = menuItems.value[currentFocusIndex.value]
    if (currentItem) {
      currentItem.focus()
    }
  }
  
  return {
    handleKeyDown,
    currentFocusIndex
  }
}
```

## 9. 测试规范

### 9.1 菜单功能测试

```typescript
// 菜单组件测试
import { mount } from '@vue/test-utils'
import MenuComponent from '@/components/Menu.vue'

describe('Menu Component', () => {
  it('should render menu items correctly', () => {
    const menuItems = [
      { id: '1', title: '学习', icon: '/icons/study.png' },
      { id: '2', title: '进度', icon: '/icons/progress.png' }
    ]
    
    const wrapper = mount(MenuComponent, {
      props: { items: menuItems }
    })
    
    expect(wrapper.findAll('.menu-item')).toHaveLength(2)
    expect(wrapper.text()).toContain('学习')
    expect(wrapper.text()).toContain('进度')
  })
  
  it('should handle menu item click', async () => {
    const wrapper = mount(MenuComponent, {
      props: {
        items: [{ id: '1', title: '学习', icon: '/icons/study.png' }]
      }
    })
    
    await wrapper.find('.menu-item').trigger('click')
    
    expect(wrapper.emitted('menu-click')).toBeTruthy()
    expect(wrapper.emitted('menu-click')[0]).toEqual([{ id: '1' }])
  })
  
  it('should support keyboard navigation', async () => {
    const wrapper = mount(MenuComponent, {
      props: {
        items: [
          { id: '1', title: '学习', icon: '/icons/study.png' },
          { id: '2', title: '进度', icon: '/icons/progress.png' }
        ]
      }
    })
    
    const firstItem = wrapper.find('.menu-item')
    await firstItem.trigger('keydown', { key: 'ArrowDown' })
    
    // 验证焦点移动
    expect(wrapper.vm.currentFocusIndex).toBe(1)
  })
})
```

### 9.2 权限测试

```typescript
// 权限相关测试
import { useAuthStore } from '@/store/modules/auth'
import { useMenuStore } from '@/store/modules/menu'

describe('Menu Permissions', () => {
  it('should show correct menus for student role', () => {
    const authStore = useAuthStore()
    const menuStore = useMenuStore()
    
    authStore.setUserRole('student')
    const visibleMenus = menuStore.getVisibleMenus()
    
    expect(visibleMenus).toContain('learning')
    expect(visibleMenus).toContain('progress')
    expect(visibleMenus).not.toContain('admin')
  })
  
  it('should show admin menus for admin role', () => {
    const authStore = useAuthStore()
    const menuStore = useMenuStore()
    
    authStore.setUserRole('admin')
    const visibleMenus = menuStore.getVisibleMenus()
    
    expect(visibleMenus).toContain('admin')
    expect(visibleMenus).toContain('user-management')
  })
})
```

## 10. 最佳实践总结

### 10.1 设计建议

1. **层级控制**：菜单深度不超过4级，避免用户迷失
2. **功能聚合**：相关功能归类，减少认知负担
3. **视觉层次**：使用颜色、大小、间距建立清晰层次
4. **一致性**：保持图标、文字、交互的一致性
5. **反馈及时**：提供清晰的状态反馈和加载提示

### 10.2 开发建议

1. **组件化**：菜单功能模块化，便于维护和复用
2. **数据驱动**：菜单配置数据化，支持动态更新
3. **性能优化**：合理使用缓存和懒加载
4. **测试覆盖**：确保菜单功能和权限的测试覆盖
5. **无障碍**：考虑特殊用户群体的使用需求

### 10.3 维护建议

1. **版本控制**：菜单配置变更需要版本管理
2. **文档更新**：及时更新菜单设计文档
3. **用户反馈**：收集用户使用反馈，持续优化
4. **性能监控**：监控菜单加载性能和用户行为
5. **定期审查**：定期审查菜单结构的合理性

---

本规范将随着产品发展和用户反馈持续优化，确保小程序菜单系统的用户体验和开发效率。