# 角色系统优化实施方案

## 🎯 实施目标

解决当前角色系统中数据源不一致、组件使用不统一等问题，实现完全自动化和一致的角色管理体验。

## 📋 实施步骤

### 第一阶段：统一角色数据源（高优先级）

#### 步骤1：创建角色服务层

**文件：`apps/accounts/services/__init__.py`**
```python
# 创建服务层包
```

**文件：`apps/accounts/services/role_service.py`**
```python
from django.core.cache import cache
from django.db.models import Q
from typing import List, Dict, Tuple, Optional
from apps.accounts.models import UserRole
from apps.permissions.models import RoleManagement


class RoleService:
    """统一的角色数据服务"""
    
    CACHE_KEY_ALL_ROLES = 'role_service:all_roles'
    CACHE_KEY_ROLE_CHOICES = 'role_service:role_choices'
    CACHE_KEY_ROLE_HIERARCHY = 'role_service:role_hierarchy'
    CACHE_TIMEOUT = 300  # 5分钟缓存
    
    @classmethod
    def get_all_roles(cls, include_inactive: bool = False) -> List[Dict]:
        """获取所有角色的统一接口"""
        cache_key = f"{cls.CACHE_KEY_ALL_ROLES}:{include_inactive}"
        roles = cache.get(cache_key)
        
        if roles is None:
            roles = []
            
            # 1. 添加预定义角色
            predefined_roles = {choice[0]: choice[1] for choice in UserRole.choices}
            
            # 2. 获取角色管理中的所有角色
            query = RoleManagement.objects.all()
            if not include_inactive:
                query = query.filter(is_active=True)
            
            role_management_data = query.values(
                'role', 'display_name', 'description', 'is_active', 'sort_order'
            ).order_by('sort_order', 'role')
            
            # 3. 合并角色数据
            processed_roles = set()
            
            for rm_data in role_management_data:
                role_code = rm_data['role']
                if role_code and role_code not in processed_roles:
                    roles.append({
                        'code': role_code,
                        'display_name': rm_data['display_name'] or predefined_roles.get(role_code, role_code),
                        'description': rm_data['description'] or '',
                        'is_predefined': role_code in predefined_roles,
                        'is_active': rm_data['is_active'],
                        'sort_order': rm_data['sort_order'] or 999
                    })
                    processed_roles.add(role_code)
            
            # 4. 添加未在角色管理中的预定义角色
            for role_code, role_name in UserRole.choices:
                if role_code not in processed_roles:
                    roles.append({
                        'code': role_code,
                        'display_name': role_name,
                        'description': f'系统预定义角色：{role_name}',
                        'is_predefined': True,
                        'is_active': True,
                        'sort_order': 0
                    })
            
            # 5. 排序
            roles.sort(key=lambda x: (x['sort_order'], x['code']))
            
            cache.set(cache_key, roles, cls.CACHE_TIMEOUT)
        
        return roles
    
    @classmethod
    def get_role_choices(cls, include_inactive: bool = False) -> List[Tuple[str, str]]:
        """获取角色选择项的统一接口"""
        cache_key = f"{cls.CACHE_KEY_ROLE_CHOICES}:{include_inactive}"
        choices = cache.get(cache_key)
        
        if choices is None:
            choices = [('', '---------')]  # 空选项
            
            roles = cls.get_all_roles(include_inactive=include_inactive)
            for role in roles:
                if include_inactive or role['is_active']:
                    choices.append((role['code'], role['display_name']))
            
            cache.set(cache_key, choices, cls.CACHE_TIMEOUT)
        
        return choices
    
    @classmethod
    def get_role_hierarchy(cls) -> Dict[str, List[str]]:
        """获取角色层级关系"""
        hierarchy = cache.get(cls.CACHE_KEY_ROLE_HIERARCHY)
        
        if hierarchy is None:
            hierarchy = {}
            
            # 从RoleManagement获取父子关系
            role_relations = RoleManagement.objects.filter(
                is_active=True,
                parent__isnull=False
            ).values('role', 'parent__role')
            
            for relation in role_relations:
                parent = relation['parent__role']
                child = relation['role']
                
                if parent not in hierarchy:
                    hierarchy[parent] = []
                hierarchy[parent].append(child)
            
            cache.set(cls.CACHE_KEY_ROLE_HIERARCHY, hierarchy, cls.CACHE_TIMEOUT)
        
        return hierarchy
    
    @classmethod
    def get_role_info(cls, role_code: str) -> Optional[Dict]:
        """获取单个角色的详细信息"""
        roles = cls.get_all_roles(include_inactive=True)
        for role in roles:
            if role['code'] == role_code:
                return role
        return None
    
    @classmethod
    def clear_cache(cls):
        """清除角色相关缓存"""
        cache.delete_many([
            f"{cls.CACHE_KEY_ALL_ROLES}:True",
            f"{cls.CACHE_KEY_ALL_ROLES}:False",
            f"{cls.CACHE_KEY_ROLE_CHOICES}:True",
            f"{cls.CACHE_KEY_ROLE_CHOICES}:False",
            cls.CACHE_KEY_ROLE_HIERARCHY
        ])
    
    @classmethod
    def refresh_cache(cls):
        """刷新角色缓存"""
        cls.clear_cache()
        # 预热缓存
        cls.get_all_roles(include_inactive=False)
        cls.get_all_roles(include_inactive=True)
        cls.get_role_choices(include_inactive=False)
        cls.get_role_choices(include_inactive=True)
        cls.get_role_hierarchy()
```

#### 步骤2：重构Widget使用统一数据源

**修改文件：`apps/permissions/widgets.py`**
```python
from django import forms
from django.utils.html import format_html
from django.urls import reverse
from apps.accounts.services.role_service import RoleService
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .models import RoleManagement
else:
    try:
        from .models import RoleManagement
    except ImportError:
        RoleManagement = None


class StandardRoleSelectWidget(forms.Select):
    """标准角色选择器Widget - 使用统一数据源"""
    
    def __init__(self, attrs=None, choices=(), include_inactive=False):
        self.include_inactive = include_inactive
        default_attrs = {
            'id': 'id_role',
            'class': 'form-control standard-role-selector'
        }
        if attrs:
            default_attrs.update(attrs)
        super().__init__(default_attrs, choices)
    
    def get_role_choices(self):
        """获取角色选择项 - 使用统一服务"""
        return RoleService.get_role_choices(include_inactive=self.include_inactive)
    
    def render(self, name, value, attrs=None, renderer=None):
        """渲染Widget"""
        # 更新选择项
        self.choices = self.get_role_choices()
        
        # 渲染基础选择器
        html = super().render(name, value, attrs, renderer)
        
        # 返回基础HTML，移除JavaScript支持
        return html
    
    class Media:
        css = {
            'all': ('admin/css/dynamic_role_selector.css',)
        }
        js = ('admin/js/dynamic_role_selector.js',)


class StandardRoleChoiceField(forms.ChoiceField):
    """标准角色选择字段 - 使用统一数据源"""
    
    def __init__(self, *args, include_inactive=False, **kwargs):
        self.include_inactive = include_inactive
        
        # 设置默认widget
        if 'widget' not in kwargs:
            kwargs['widget'] = StandardRoleSelectWidget(include_inactive=include_inactive)
        
        # 设置选择项
        if 'choices' not in kwargs:
            kwargs['choices'] = self.get_role_choices()
        
        super().__init__(*args, **kwargs)
    
    def get_role_choices(self):
        """获取角色选择项 - 使用统一服务"""
        return RoleService.get_role_choices(include_inactive=self.include_inactive)
    
    def validate(self, value):
        """验证角色值"""
        super().validate(value)
        if value and value != '':
            role_info = RoleService.get_role_info(value)
            if not role_info:
                raise forms.ValidationError(f'无效的角色代码: {value}')
            if not self.include_inactive and not role_info['is_active']:
                raise forms.ValidationError(f'角色 {value} 已被禁用')


class RoleTextInputWidget(forms.TextInput):
    """角色文本输入Widget - 用于创建新角色"""
    
    def __init__(self, attrs=None):
        default_attrs = {
            'id': 'id_role',
            'class': 'form-control role-text-input',
            'placeholder': '请输入新角色标识（如：custom_role）',
            'pattern': '[a-z_][a-z0-9_]*',  # 角色代码格式验证
            'title': '角色代码只能包含小写字母、数字和下划线，且必须以字母或下划线开头'
        }
        if attrs:
            default_attrs.update(attrs)
        super().__init__(default_attrs)
    
    def render(self, name, value, attrs=None, renderer=None):
        """渲染Widget"""
        html = super().render(name, value, attrs, renderer)
        
        # 添加实时验证JavaScript
        js_code = """
        <script>
        document.addEventListener('DOMContentLoaded', function() {
            const roleInput = document.querySelector('.role-text-input');
            if (roleInput && !roleInput.hasAttribute('data-validated')) {
                roleInput.setAttribute('data-validated', 'true');
                
                roleInput.addEventListener('input', function(e) {
                    const value = e.target.value;
                    const isValid = /^[a-z_][a-z0-9_]*$/.test(value);
                    
                    if (value && !isValid) {
                        e.target.style.borderColor = '#dc3545';
                        e.target.style.backgroundColor = '#fff5f5';
                    } else {
                        e.target.style.borderColor = '';
                        e.target.style.backgroundColor = '';
                    }
                });
            }
        });
        </script>
        """
        
        return format_html('{0}{1}', html, js_code)
```

#### 步骤3：创建缓存刷新信号

**文件：`apps/accounts/signals.py`**
```python
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from apps.permissions.models import RoleManagement
from apps.accounts.services.role_service import RoleService


@receiver([post_save, post_delete], sender=RoleManagement)
def refresh_role_cache(sender, **kwargs):
    """角色管理数据变更时刷新缓存"""
    RoleService.refresh_cache()
    print(f"角色缓存已刷新: {kwargs.get('instance', 'Unknown')}")
```

**修改文件：`apps/accounts/apps.py`**
```python
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.accounts'
    verbose_name = '用户账户管理'
    
    def ready(self):
        # 导入信号处理器
        import apps.accounts.signals
```

### 第二阶段：统一Admin类实现（高优先级）

#### 步骤4：修复RoleMenuPermissionAdmin

**修改文件：`apps/permissions/admin.py`**
```python
# 在文件开头添加导入
from .role_selector_config import StandardRoleAdminMixin

# 修改RoleMenuPermissionAdmin类
@admin.register(RoleMenuPermission)
class RoleMenuPermissionAdmin(StandardRoleAdminMixin, admin.ModelAdmin):
    """角色菜单权限Admin - 使用统一角色选择器"""
    list_display = ['role', 'menu_module', 'get_permission_status', 'created_at']
    list_filter = ['role', 'can_access', 'created_at']
    search_fields = ['menu_module__name', 'menu_module__key']
    ordering = ['role', 'menu_module__name']
    
    def get_permission_status(self, obj):
        """显示权限状态"""
        if obj.can_access:
            return format_html(
                '<span style="color: #28a745; background: #d4edda; padding: 2px 6px; border-radius: 3px; font-size: 12px;">'  
                '✓ 可访问</span>'
            )
        else:
            return format_html(
                '<span style="color: #dc3545; background: #f8d7da; padding: 2px 6px; border-radius: 3px; font-size: 12px;">'  
                '✗ 禁止访问</span>'
            )
    
    get_permission_status.short_description = '权限状态'
    
    fieldsets = (
        ('基本信息', {
            'fields': ('role', 'menu_module')
        }),
        ('权限设置', {
            'fields': ('can_access',)
        }),
    )
    
    # 角色选择器配置已通过StandardRoleAdminMixin自动处理
```

#### 步骤5：创建Admin类验证装饰器

**文件：`apps/permissions/decorators.py`**
```python
from functools import wraps
from django.contrib import admin
from .role_selector_config import StandardRoleAdminMixin, RoleCreationAdminMixin


def ensure_standard_role_selector(admin_class):
    """确保Admin类使用标准角色选择器的装饰器"""
    
    def decorator(cls):
        # 检查是否继承了正确的混入类
        has_standard_mixin = issubclass(cls, StandardRoleAdminMixin)
        has_creation_mixin = issubclass(cls, RoleCreationAdminMixin)
        
        if not (has_standard_mixin or has_creation_mixin):
            raise ValueError(
                f"Admin类 {cls.__name__} 必须继承 StandardRoleAdminMixin 或 RoleCreationAdminMixin "
                f"以确保使用统一的角色选择器"
            )
        
        # 添加验证标记
        cls._role_selector_validated = True
        
        return cls
    
    return decorator


def validate_all_role_admins():
    """验证所有注册的Admin类是否正确使用角色选择器"""
    issues = []
    
    for model, admin_class in admin.site._registry.items():
        # 检查是否有role字段
        if hasattr(model, 'role'):
            # 检查是否使用了正确的混入类
            has_standard_mixin = issubclass(admin_class, StandardRoleAdminMixin)
            has_creation_mixin = issubclass(admin_class, RoleCreationAdminMixin)
            
            if not (has_standard_mixin or has_creation_mixin):
                issues.append({
                    'model': model.__name__,
                    'admin_class': admin_class.__name__,
                    'issue': '未使用标准角色选择器混入类'
                })
    
    return issues
```

### 第三阶段：API接口统一（中优先级）

#### 步骤6：创建统一角色API

**文件：`apps/accounts/api/role_api.py`**
```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.core.cache import cache
from apps.accounts.services.role_service import RoleService
from apps.accounts.models import CustomUser
from django.db.models import Count


class RoleAPIViewSet(viewsets.ViewSet):
    """统一角色管理API"""
    permission_classes = [IsAuthenticated]
    
    @action(detail=False, methods=['get'])
    def list_roles(self, request):
        """获取所有角色列表"""
        include_inactive = request.query_params.get('include_inactive', 'false').lower() == 'true'
        roles = RoleService.get_all_roles(include_inactive=include_inactive)
        
        return Response({
            'success': True,
            'data': roles,
            'total': len(roles)
        })
    
    @action(detail=False, methods=['get'])
    def role_choices(self, request):
        """获取角色选择项"""
        include_inactive = request.query_params.get('include_inactive', 'false').lower() == 'true'
        choices = RoleService.get_role_choices(include_inactive=include_inactive)
        
        # 转换为API友好的格式
        formatted_choices = [
            {'value': choice[0], 'label': choice[1]} 
            for choice in choices
        ]
        
        return Response({
            'success': True,
            'data': formatted_choices
        })
    
    @action(detail=False, methods=['get'])
    def role_hierarchy(self, request):
        """获取角色层级关系"""
        hierarchy = RoleService.get_role_hierarchy()
        
        return Response({
            'success': True,
            'data': hierarchy
        })
    
    @action(detail=True, methods=['get'])
    def role_info(self, request, pk=None):
        """获取单个角色详细信息"""
        role_info = RoleService.get_role_info(pk)
        
        if not role_info:
            return Response({
                'success': False,
                'error': f'角色 {pk} 不存在'
            }, status=status.HTTP_404_NOT_FOUND)
        
        # 添加用户统计信息
        user_count = CustomUser.objects.filter(role=pk, is_active=True).count()
        role_info['user_count'] = user_count
        
        return Response({
            'success': True,
            'data': role_info
        })
    
    @action(detail=False, methods=['get'])
    def role_statistics(self, request):
        """获取角色统计信息"""
        # 使用缓存提高性能
        cache_key = 'role_api:statistics'
        stats = cache.get(cache_key)
        
        if stats is None:
            # 统计各角色用户数量
            role_stats = CustomUser.objects.filter(
                is_active=True
            ).values('role').annotate(
                user_count=Count('id')
            ).order_by('role')
            
            # 获取角色显示名称
            roles_info = {role['code']: role for role in RoleService.get_all_roles()}
            
            stats = []
            for stat in role_stats:
                role_code = stat['role']
                role_info = roles_info.get(role_code, {})
                
                stats.append({
                    'role_code': role_code,
                    'role_name': role_info.get('display_name', role_code),
                    'user_count': stat['user_count'],
                    'is_predefined': role_info.get('is_predefined', False),
                    'is_active': role_info.get('is_active', True)
                })
            
            cache.set(cache_key, stats, 300)  # 5分钟缓存
        
        return Response({
            'success': True,
            'data': stats
        })
    
    @action(detail=False, methods=['post'])
    def refresh_cache(self, request):
        """刷新角色缓存"""
        if not request.user.is_staff:
            return Response({
                'success': False,
                'error': '权限不足'
            }, status=status.HTTP_403_FORBIDDEN)
        
        RoleService.refresh_cache()
        cache.delete('role_api:statistics')
        
        return Response({
            'success': True,
            'message': '角色缓存已刷新'
        })
```

#### 步骤7：注册API路由

**修改文件：`apps/accounts/urls.py`**
```python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .api.role_api import RoleAPIViewSet

# 创建API路由
api_router = DefaultRouter()
api_router.register(r'roles', RoleAPIViewSet, basename='role')

urlpatterns = [
    # 其他URL模式...
    path('api/', include(api_router.urls)),
]
```

### 第四阶段：前端增强（中优先级）

#### 步骤8：增强角色选择器JavaScript

**文件：`static/admin/js/enhanced_role_selector.js`**
```javascript
/**
 * 增强角色选择器
 * 提供实时数据加载、验证和交互功能
 */
class EnhancedRoleSelector {
    constructor(element, options = {}) {
        this.element = element;
        this.options = {
            apiEndpoint: '/accounts/api/roles/',
            enablePreview: true,
            enableValidation: true,
            cacheTimeout: 300000, // 5分钟
            ...options
        };
        
        this.cache = new Map();
        this.init();
    }
    
    init() {
        this.setupEventListeners();
        this.loadRoles();
        
        if (this.options.enablePreview) {
            this.setupPreview();
        }
        
        if (this.options.enableValidation) {
            this.setupValidation();
        }
    }
    
    setupEventListeners() {
        this.element.addEventListener('change', (e) => {
            this.onRoleChange(e.target.value);
        });
        
        // 角色变更事件监听已移除
    }
    
    async loadRoles(forceRefresh = false) {
        const cacheKey = 'roles_list';
        const cached = this.cache.get(cacheKey);
        
        if (!forceRefresh && cached && (Date.now() - cached.timestamp < this.options.cacheTimeout)) {
            this.updateOptions(cached.data);
            return cached.data;
        }
        
        try {
            const response = await fetch(`${this.options.apiEndpoint}role_choices/`);
            const result = await response.json();
            
            if (result.success) {
                this.cache.set(cacheKey, {
                    data: result.data,
                    timestamp: Date.now()
                });
                
                this.updateOptions(result.data);
                return result.data;
            } else {
                console.error('Failed to load roles:', result.error);
            }
        } catch (error) {
            console.error('Error loading roles:', error);
        }
    }
    
    updateOptions(roles) {
        const currentValue = this.element.value;
        
        // 清空现有选项
        this.element.innerHTML = '';
        
        // 添加空选项
        const emptyOption = document.createElement('option');
        emptyOption.value = '';
        emptyOption.textContent = '---------';
        this.element.appendChild(emptyOption);
        
        // 添加角色选项
        roles.forEach(role => {
            if (role.value) { // 跳过空值
                const option = document.createElement('option');
                option.value = role.value;
                option.textContent = role.label;
                this.element.appendChild(option);
            }
        });
        
        // 恢复之前的值
        this.element.value = currentValue;
    }
    
    setupPreview() {
        // 创建预览容器
        const previewContainer = document.createElement('div');
        previewContainer.className = 'role-preview-container';
        previewContainer.style.cssText = `
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            display: none;
        `;
        
        this.element.parentNode.appendChild(previewContainer);
        this.previewContainer = previewContainer;
    }
    
    async showRolePreview(roleCode) {
        if (!this.previewContainer || !roleCode) {
            if (this.previewContainer) {
                this.previewContainer.style.display = 'none';
            }
            return;
        }
        
        try {
            const response = await fetch(`${this.options.apiEndpoint}${roleCode}/role_info/`);
            const result = await response.json();
            
            if (result.success) {
                const roleInfo = result.data;
                this.previewContainer.innerHTML = `
                    <h4 style="margin: 0 0 8px 0; color: #495057;">角色信息预览</h4>
                    <div><strong>角色名称：</strong>${roleInfo.display_name}</div>
                    <div><strong>角色代码：</strong>${roleInfo.code}</div>
                    <div><strong>描述：</strong>${roleInfo.description || '无'}</div>
                    <div><strong>类型：</strong>${roleInfo.is_predefined ? '系统预定义' : '自定义角色'}</div>
                    <div><strong>用户数量：</strong>${roleInfo.user_count || 0}</div>
                    <div><strong>状态：</strong><span style="color: ${roleInfo.is_active ? '#28a745' : '#dc3545'}">${roleInfo.is_active ? '启用' : '禁用'}</span></div>
                `;
                this.previewContainer.style.display = 'block';
            }
        } catch (error) {
            console.error('Error loading role preview:', error);
        }
    }
    
    setupValidation() {
        this.element.addEventListener('change', (e) => {
            this.validateRole(e.target.value);
        });
    }
    
    async validateRole(roleCode) {
        if (!roleCode) return true;
        
        try {
            const response = await fetch(`${this.options.apiEndpoint}${roleCode}/role_info/`);
            const result = await response.json();
            
            if (result.success) {
                const roleInfo = result.data;
                
                // 检查角色是否启用
                if (!roleInfo.is_active) {
                    this.showValidationError('所选角色已被禁用');
                    return false;
                }
                
                this.clearValidationError();
                return true;
            } else {
                this.showValidationError('无效的角色选择');
                return false;
            }
        } catch (error) {
            console.error('Error validating role:', error);
            return false;
        }
    }
    
    showValidationError(message) {
        this.clearValidationError();
        
        const errorDiv = document.createElement('div');
        errorDiv.className = 'role-validation-error';
        errorDiv.style.cssText = `
            color: #dc3545;
            font-size: 12px;
            margin-top: 5px;
            padding: 5px;
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 3px;
        `;
        errorDiv.textContent = message;
        
        this.element.parentNode.appendChild(errorDiv);
        this.element.style.borderColor = '#dc3545';
    }
    
    clearValidationError() {
        const existingError = this.element.parentNode.querySelector('.role-validation-error');
        if (existingError) {
            existingError.remove();
        }
        this.element.style.borderColor = '';
    }
    
    onRoleChange(roleCode) {
        if (this.options.enablePreview) {
            this.showRolePreview(roleCode);
        }
        
        // 自定义事件触发已移除
    }
    
    syncWithOtherSelectors(roleCode) {
        // 可以在这里实现与其他角色选择器的同步逻辑
        console.log('Syncing with other selectors:', roleCode);
    }
    
    async refresh() {
        await this.loadRoles(true);
    }
    
    destroy() {
        if (this.previewContainer) {
            this.previewContainer.remove();
        }
        
        const errorDiv = this.element.parentNode.querySelector('.role-validation-error');
        if (errorDiv) {
            errorDiv.remove();
        }
    }
}

// 全局初始化已移除
// 角色选择器自动增强功能已禁用

// 导出到全局
window.EnhancedRoleSelector = EnhancedRoleSelector;
```

### 第五阶段：性能优化（中优先级）

#### 步骤9：数据库索引优化

**文件：`apps/accounts/migrations/0010_optimize_role_indexes.py`**
```python
from django.db import migrations, models


class Migration(migrations.Migration):
    
    dependencies = [
        ('accounts', '0009_add_role_template_system'),
    ]
    
    operations = [
        # 为CustomUser.role添加索引
        migrations.RunSQL(
            "CREATE INDEX IF NOT EXISTS accounts_customuser_role_active_idx ON accounts_customuser (role, is_active);",
            reverse_sql="DROP INDEX IF EXISTS accounts_customuser_role_active_idx;"
        ),
        
        # 为RoleExtension添加复合索引
        migrations.RunSQL(
            "CREATE INDEX IF NOT EXISTS accounts_roleextension_role_active_idx ON accounts_roleextension (role, is_active);",
            reverse_sql="DROP INDEX IF EXISTS accounts_roleextension_role_active_idx;"
        ),
        
        # 为UserExtensionData添加复合索引
        migrations.RunSQL(
            "CREATE INDEX IF NOT EXISTS accounts_userextensiondata_user_role_idx ON accounts_userextensiondata (user_id, role_extension_id);",
            reverse_sql="DROP INDEX IF EXISTS accounts_userextensiondata_user_role_idx;"
        ),
    ]
```

#### 步骤10：查询优化

**文件：`apps/accounts/managers.py`**
```python
from django.db import models
from django.db.models import Prefetch


class CustomUserManager(models.Manager):
    """优化的用户管理器"""
    
    def with_role_data(self):
        """预加载角色相关数据"""
        return self.select_related(
            'role_level'
        ).prefetch_related(
            'groups',
            Prefetch(
                'user_extensions',
                queryset=models.get_model('accounts', 'UserExtensionData').objects.select_related('role_extension')
            )
        )
    
    def by_role(self, role, active_only=True):
        """按角色筛选用户"""
        queryset = self.filter(role=role)
        if active_only:
            queryset = queryset.filter(is_active=True)
        return queryset.with_role_data()
    
    def role_statistics(self):
        """角色统计查询"""
        return self.filter(
            is_active=True
        ).values('role').annotate(
            user_count=models.Count('id')
        ).order_by('role')


class RoleExtensionManager(models.Manager):
    """角色增项管理器"""
    
    def active_for_role(self, role):
        """获取指定角色的活跃增项"""
        return self.filter(
            role=role,
            is_active=True
        ).order_by('sort_order', 'field_name')
    
    def with_user_data(self, user):
        """预加载用户增项数据"""
        return self.prefetch_related(
            Prefetch(
                'userextensiondata_set',
                queryset=models.get_model('accounts', 'UserExtensionData').objects.filter(user=user)
            )
        )
```

**修改文件：`apps/accounts/models.py`**
```python
# 在CustomUser模型中添加
class CustomUser(AbstractUser):
    # ... 现有字段 ...
    
    objects = CustomUserManager()  # 使用自定义管理器
    
    class Meta:
        verbose_name = '用户'
        verbose_name_plural = '用户管理'
        indexes = [
            models.Index(fields=['role', 'is_active']),
            models.Index(fields=['role', 'date_joined']),
        ]

# 在RoleExtension模型中添加
class RoleExtension(models.Model):
    # ... 现有字段 ...
    
    objects = RoleExtensionManager()  # 使用自定义管理器
    
    class Meta:
        verbose_name = '角色增项配置'
        verbose_name_plural = '角色增项配置管理'
        indexes = [
            models.Index(fields=['role', 'is_active']),
            models.Index(fields=['role', 'sort_order']),
        ]
```

## 🧪 测试方案

### 单元测试

**文件：`apps/accounts/tests/test_role_service.py`**
```python
from django.test import TestCase
from django.core.cache import cache
from apps.accounts.services.role_service import RoleService
from apps.accounts.models import UserRole
from apps.permissions.models import RoleManagement


class RoleServiceTest(TestCase):
    
    def setUp(self):
        cache.clear()
        
        # 创建测试角色
        self.test_role = RoleManagement.objects.create(
            role='test_role',
            display_name='测试角色',
            description='用于测试的角色',
            is_active=True,
            sort_order=100
        )
    
    def test_get_all_roles(self):
        """测试获取所有角色"""
        roles = RoleService.get_all_roles()
        
        # 应该包含预定义角色和自定义角色
        role_codes = [role['code'] for role in roles]
        
        # 检查预定义角色
        for role_code, _ in UserRole.choices:
            self.assertIn(role_code, role_codes)
        
        # 检查自定义角色
        self.assertIn('test_role', role_codes)
    
    def test_get_role_choices(self):
        """测试获取角色选择项"""
        choices = RoleService.get_role_choices()
        
        # 应该是元组列表格式
        self.assertIsInstance(choices, list)
        self.assertTrue(all(isinstance(choice, tuple) and len(choice) == 2 for choice in choices))
        
        # 应该包含空选项
        self.assertEqual(choices[0], ('', '---------'))
    
    def test_cache_functionality(self):
        """测试缓存功能"""
        # 第一次调用
        roles1 = RoleService.get_all_roles()
        
        # 第二次调用应该使用缓存
        roles2 = RoleService.get_all_roles()
        
        self.assertEqual(roles1, roles2)
        
        # 清除缓存后应该重新加载
        RoleService.clear_cache()
        roles3 = RoleService.get_all_roles()
        
        self.assertEqual(roles1, roles3)
    
    def test_role_info(self):
        """测试获取角色信息"""
        role_info = RoleService.get_role_info('test_role')
        
        self.assertIsNotNone(role_info)
        self.assertEqual(role_info['code'], 'test_role')
        self.assertEqual(role_info['display_name'], '测试角色')
        self.assertFalse(role_info['is_predefined'])
        self.assertTrue(role_info['is_active'])
```

### 集成测试

**文件：`apps/accounts/tests/test_role_integration.py`**
```python
from django.test import TestCase, Client
from django.contrib.auth import get_user_model
from django.urls import reverse
from apps.accounts.models import UserRole
from apps.permissions.models import RoleManagement

User = get_user_model()


class RoleIntegrationTest(TestCase):
    
    def setUp(self):
        self.client = Client()
        
        # 创建管理员用户
        self.admin_user = User.objects.create_superuser(
            username='admin',
            email='admin@test.com',
            password='testpass123'
        )
        
        # 创建测试角色
        self.test_role = RoleManagement.objects.create(
            role='integration_test_role',
            display_name='集成测试角色',
            is_active=True
        )
    
    def test_admin_role_selector(self):
        """测试Admin界面角色选择器"""
        self.client.login(username='admin', password='testpass123')
        
        # 访问用户添加页面
        response = self.client.get(reverse('admin:accounts_customuser_add'))
        self.assertEqual(response.status_code, 200)
        
        # 检查角色选择器是否包含测试角色
        self.assertContains(response, 'integration_test_role')
        self.assertContains(response, '集成测试角色')
    
    def test_api_role_endpoints(self):
        """测试角色API端点"""
        self.client.login(username='admin', password='testpass123')
        
        # 测试角色列表API
        response = self.client.get('/accounts/api/roles/list_roles/')
        self.assertEqual(response.status_code, 200)
        
        data = response.json()
        self.assertTrue(data['success'])
        self.assertIsInstance(data['data'], list)
        
        # 检查是否包含测试角色
        role_codes = [role['code'] for role in data['data']]
        self.assertIn('integration_test_role', role_codes)
    
    def test_role_cache_refresh(self):
        """测试角色缓存刷新"""
        self.client.login(username='admin', password='testpass123')
        
        # 刷新缓存
        response = self.client.post('/accounts/api/roles/refresh_cache/')
        self.assertEqual(response.status_code, 200)
        
        data = response.json()
        self.assertTrue(data['success'])
```

## 📊 监控和维护

### 性能监控

**文件：`apps/accounts/monitoring.py`**
```python
import time
import logging
from functools import wraps
from django.core.cache import cache
from django.db import connection

logger = logging.getLogger('role_system')


def monitor_role_performance(func):
    """角色操作性能监控装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        start_queries = len(connection.queries)
        
        try:
            result = func(*args, **kwargs)
            
            end_time = time.time()
            end_queries = len(connection.queries)
            
            execution_time = end_time - start_time
            query_count = end_queries - start_queries
            
            # 记录性能数据
            logger.info(f"Role operation {func.__name__}: {execution_time:.3f}s, {query_count} queries")
            
            # 如果性能较差，记录警告
            if execution_time > 1.0 or query_count > 10:
                logger.warning(f"Slow role operation detected: {func.__name__} took {execution_time:.3f}s with {query_count} queries")
            
            return result
            
        except Exception as e:
            logger.error(f"Role operation {func.__name__} failed: {str(e)}")
            raise
    
    return wrapper


class RoleSystemHealthCheck:
    """角色系统健康检查"""
    
    @staticmethod
    def check_cache_health():
        """检查缓存健康状态"""
        try:
            test_key = 'health_check_test'
            cache.set(test_key, 'test_value', 60)
            value = cache.get(test_key)
            cache.delete(test_key)
            
            return value == 'test_value'
        except Exception:
            return False
    
    @staticmethod
    def check_database_health():
        """检查数据库健康状态"""
        try:
            from apps.accounts.models import CustomUser
            CustomUser.objects.count()
            return True
        except Exception:
            return False
    
    @staticmethod
    def check_role_data_consistency():
        """检查角色数据一致性"""
        try:
            from apps.accounts.services.role_service import RoleService
            from apps.permissions.models import RoleManagement
            
            # 检查是否有孤立的角色数据
            service_roles = {role['code'] for role in RoleService.get_all_roles()}
            db_roles = set(RoleManagement.objects.values_list('role', flat=True))
            
            # 应该没有数据库中存在但服务中不存在的角色
            orphaned_roles = db_roles - service_roles
            
            return len(orphaned_roles) == 0
        except Exception:
            return False
    
    @classmethod
    def run_full_check(cls):
        """运行完整健康检查"""
        results = {
            'cache_health': cls.check_cache_health(),
            'database_health': cls.check_database_health(),
            'data_consistency': cls.check_role_data_consistency(),
        }
        
        results['overall_health'] = all(results.values())
        
        return results
```

## 🚀 部署清单

### 部署前检查

1. **代码审查**
   - [ ] 所有新文件已创建
   - [ ] 现有文件修改正确
   - [ ] 导入语句正确
   - [ ] 没有语法错误

2. **数据库迁移**
   - [ ] 运行 `python manage.py makemigrations`
   - [ ] 运行 `python manage.py migrate`
   - [ ] 检查索引是否正确创建

3. **缓存配置**
   - [ ] 确认缓存后端配置正确
   - [ ] 测试缓存读写功能

4. **静态文件**
   - [ ] 运行 `python manage.py collectstatic`
   - [ ] 确认JavaScript和CSS文件正确加载

### 部署步骤

1. **备份现有数据**
   ```bash
   python manage.py dumpdata accounts permissions > backup_before_role_optimization.json
   ```

2. **应用代码更改**
   ```bash
   git add .
   git commit -m "Implement role system optimization"
   ```

3. **运行迁移**
   ```bash
   python manage.py migrate
   ```

4. **刷新缓存**
   ```bash
   python manage.py shell -c "from apps.accounts.services.role_service import RoleService; RoleService.refresh_cache()"
   ```

5. **运行测试**
   ```bash
   python manage.py test apps.accounts.tests.test_role_service
   python manage.py test apps.accounts.tests.test_role_integration
   ```

6. **验证功能**
   - [ ] 访问Admin界面，检查角色选择器
   - [ ] 测试API端点
   - [ ] 验证缓存功能
   - [ ] 检查性能监控

### 回滚方案

如果部署出现问题，可以按以下步骤回滚：

1. **恢复代码**
   ```bash
   git revert HEAD
   ```

2. **恢复数据库**
   ```bash
   python manage.py migrate accounts 0009
   python manage.py loaddata backup_before_role_optimization.json
   ```

3. **清除缓存**
   ```bash
   python manage.py shell -c "from django.core.cache import cache; cache.clear()"
   ```

## 📈 预期效果

实施完成后，系统将实现：

1. **完全一致的角色数据源**：所有页面和API使用统一的角色服务
2. **自动化的角色管理**：角色变更自动同步到所有相关组件
3. **优化的性能**：缓存机制和数据库索引显著提升查询速度
4. **增强的用户体验**：实时验证、预览功能和统一的交互界面
5. **完善的监控体系**：性能监控和健康检查确保系统稳定运行

通过这套完整的实施方案，可以彻底解决当前角色系统中存在的问题，实现真正的统一化和自动化管理。